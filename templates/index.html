<!DOCTYPE <!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>EditLab</title>
    <link href="css/style.css" rel="stylesheet">
    <style>
    /*
    Colors:
    Primary: #17BEBB
    Shadows: #14453D / background
    Highlights: #CD5334
    2nd Highlights: #EDB88B
    */
    canvas {
      margin-top: 20px;
      margin: 10px;
      background-color: rgba(45, 45, 45, 0);
      border: 5px solid #CD5334;
      border-radius: 1rem;
    }
    /* Download, Reset, and Brush Buttons */
    .download, .reset, .brushButton {
      border-radius: 5px;
      margin: 10px;
      border: 0;
      line-height: 2.5;
      padding: 0 20px;
      font-size: 1rem;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 1px black;
      background-color: #17BEBB;
    }
    .download:hover, .reset:hover, .brushButton:hover {
      background-color: #14453D;
    }
    .download:active, .reset:active, .brushButton:active { 
      background-color: #7D84B2;
    }
    /* Eraser & Clear Buttons */
    .eraserButton, .undoButton {
      border-radius: 5px;
      margin: 10px;
      border: 0;
      line-height: 2.5;
      padding: 0 20px;
      font-size: 1rem;
      text-align: center;
      color: white;
      text-shadow: 1px 1px 1px black;
      background-color: #FF0000;
    }
    .eraserButton:hover, .undoButton:hover {
      background-color: #14453D;
    }
    .eraserButton:active, .undoButton:active { 
      background-color: #7D84B2;
    }
    
    /* Vertically Align Tools */
    .verticalTools {
      margin: 10px;
    }
    .brushColor {
      margin-top: 1%;
      vertical-align: baseline;
    }
    /* Title */
    .title {
      font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
      font-size: 50px;
      text-align: center;
    }
    /* Upload Image Card */
    .card {
      margin: 2rem;
    } 
    /* Queries Remaining Text */
    .queriesRemaining {
      margin: 10px;
    }
    </style>
    {{ bootstrap.load_css() }}
  </head>
  <body>
    <div class="sidebar">
      <h2 class="title">EditLab</h2>
            
      <!-- Add image preview (don't use api token) -->
      <!-- Upload Image Card -->
      <div class="card" style="width: 18rem;">
        <img src="..." class="card-img-top" alt="Uploaded image preview" />
        <div class="card-body">
          <h5 class="card-title">Upload Image:</h5>
          
          <!-- Choose File Input -->
          <input type="file" id="imageInput" accept=".png, .jpeg, .jpg" />

          <a href="#" class="btn btn-primary" id="uploadToCanvasButton">Load canvas</a>
        </div>
      </div> 

      <hr />

      <button class="brushButton">Brush</button>
      <button class="eraserButton">Eraser</button>
      <button class="undoButton">Undo</button>
      <h4 class="queriesRemaining">Queries Remaining: <span class="fst-italic">{{ credits_remaining() }}</span></h4>

      <!-- Brush Tools -->
      <div class="brushTools">
        
        <div class="verticalTools">

          <!-- Filter Dropdown -->
          <div class="row gap-1">
            <div class="col-sm-3">
              <div class="form-floating">
                <select class="form-select" name="Filters" id="filters">
                  <option selected>Filters</option>
                  <!-- POPULATE DROPDOWN -->
                  {% for filter in effect_list %}
                    <option value="{{filter}}">{{ filter }}</option>
                  {% endfor %}
                </select>
                <label for="filters">Choose a filter:</label>
              </div>
            </div>            
            <div class="col-sm-3">
              <!-- Brush Size Input -->
              <label for="brushSize" class="form-label">
                Brush Size <span id="currentBrushSize">5</span>:
                <input type="range" class="form-range" id="brushSize" min="1" max="21" step="5" value="5" />
              </label>

              <!-- Brush Color Input -->
              <label for="brushColor" class="form-label">Color:
                <input type="color" class="form-control form-control-color" id="brushColor" value="#000000" /> 
              </label>
            </div>
            <div class="col-sm-2">
              <!-- Chroma Key Options Dropdown -->
              <div class="form-floating">
                <select class="form-select" name="Chroma Filters" id="chromaKey">
                  <option selected>Chroma Filters</option>
                  <option value="chroma_bg_remove">Background Remove Chroma Key</option>
                  <option value="reverse_chroma_foreground_remove">Foreground Remove Reverse Chroma Key</option>
                  <option value="replace_img_chroma">Replace Image Chroma Key</option>
                </select>                
                <label for="chromaKey">
                  Choose a key:
                </label>
              </div> 
            </div>
            <div id="invisibility" class="d-none">
              <input type="file" id="secondImageUpload" accept=".png, .jpeg, .jpg" />
              
              <a href="#" class="btn btn-primary" id="secondUpload">Submit For Chroma Key</a>
            </div>
          </div>
        </div>
      </div>

      <!-- Drawing Canvas -->
      <div class="canvas-wrapper">
        <canvas id="canvasImage" width="800" height="600">
          Your browser doesn't support the canvas tag.         
        </canvas>
      </div>

      <div class="downloadAndReset">
        <!-- Display Download Option -->
        <button class="download">Download</button>

        <!-- Display Reset Image Button -->
        <button class="reset">Reset Image</button>
      </div>
    </div>
    
    <script type="text/javascript">
    // elements for preview of image
    let imageInput = document.querySelector("#imageInput");
    let previewImage = document.querySelector(".card-img-top");
    let uploadCanvasButton = document.querySelector("#uploadToCanvasButton");

    // saved image url, updated when image is changed to something else
    var previousImageUrl = null;
    
    // elements for image filter api
    
    // elements for canvas
    let canvas = document.querySelector("#canvasImage");
    var ctx = canvas.getContext("2d");
    
    let currentFileUrl = null;
    let currentFile = null;
    
    /* Displaying Preview of Image */
    imageInput.addEventListener('change', function(event) {
      currentFile = event.target.files[0];
      originalFile = currentFile; // only change here -> for resetting the image
      
      getUrl(currentFile);

      previewImage.src = currentFileUrl;
    });
    
    
    /* Setting background to preview image */
    uploadCanvasButton.addEventListener('click', function(event) {
      if (!currentFile) {
        console.warn("No file selected");
        return;
      }
      
      updateCanvasWithUrl(currentFileUrl);
    });

    /* Create 2 separate canvases, one for background/filters & one for drawing */
    
    /* API Dropdown -> First Get Data From Backend To Populate Dropdown */
    // dropdown element
    const select = document.querySelector("#filters");

    // get value of selected filter and pass to apply_effect
    select.addEventListener('change', async function(event) {
      // ---- if there's no file in the canvas ----
      if (!currentFile) { 
        console.warn("No file selected")
        return;
      }

      // currently selected dropdown option
      const currentlySelected = select.value;

      // saves the old version of the image to revert
      previousImageUrl = currentFileUrl; 

      // getting data to pass to backend
      const formData = new FormData();
      formData.append('file', currentFile); // original image
      formData.append('effect', currentlySelected);

      /* -- TRY TO GET DATA FROM API USING FORM -- */
      try {
        const response = await fetch('/apply-effect', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          console.error("Error from server");
          return;
        }
        
        // read binary data response with blob
        const blob = await response.blob();
        const blobUrl = getUrl(blob);
        
        // draw to canvas
        // currentFileUrl is updated in getUrl
        updateCanvasWithUrl(currentFileUrl);
      } catch (err) {
        console.error("Fetch Error {Filters}: ", err);
      }
      // to reverse- save current image file
    });
    
    /* ---- PASS DATA TO CHROMA KEY METHODS ---- */
    const chromaSelect = document.querySelector("#chromaKey");
    const color = document.querySelector("#brushColor");
    
    // options from dropdown
    const defaultChroma = document.querySelector("#chroma_bg_remove");
    const reverseChroma = document.querySelector("#reverse_chroma_foreground_remove");
    const replaceImg = document.querySelector("#replace_img_chroma");
    const getVisibility = document.querySelector("#invisibility");


    chromaSelect.addEventListener('change', async function(event) {
      if (!currentFile) {
        console.warn("No file selected");
        return;
      }
      
      // get currently selected option
      const currentlySelected = chromaSelect.value;

      // get visibility & change for 2nd uploaded image (to replace background)
      if (currentlySelected === "replace_img_chroma") {
        // check upload image visibility
        if (getVisibility.classList.contains("d-none")) {
          getVisibility.classList.remove("d-none");
        }
      }
      
      // get current color
      const currentColor = color.value;

      // set undo save
      previousImageUrl = currentFileUrl;
      
      // create a form to pass data to backend
      const formData = new FormData();
      formData.append('file', currentFile);
      formData.append('color', currentColor);
      
      /* -- TRY TO GET DATA FROM BACKEND METHODS -- */
      try {
        const response = await fetch('/chroma-key', {
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          console.error("Error from server");
          return;
        }
        
        // read returned binary img data with blob
        const blob = await response.blob();
        getUrl(blob);

        // currentFileUrl is updated in getUrl
        updateCanvasWithUrl(currentFileUrl); 
        // read
      } catch(err) {
        console.error("Fetch error {Chroma Key}: " + err);
      }
    });
    
    /* ---- DISPLAY CURRENT BRUSH SIZE ---- */
    const rangeForm = document.querySelector("#brushSize");
    var currentSizeText = document.querySelector("#currentBrushSize");
    
    rangeForm.addEventListener('change', function(event) {
      var curText = event.target.value;
      currentSizeText.textContent = curText-1;
    });
    
    /* ---- RESET IMAGE BUTTON ---- */
    const resetButton = document.querySelector(".reset");
    
    resetButton.addEventListener('click', function() {
      if (originalFile !== null) {
        const tempUrl = getUrl(originalFile);
        updateCanvasWithUrl(tempUrl);
      }
      return; 
    });
    
    /* ---- TEMPORARY SINGLE UNDO BUTTON ---- */
    const undoButton = document.querySelector(".undo");

    undoButton.addEventListener('click', function() {
      if (previousImageUrl !== null) {
        updateCanvasWithUrl(previousImageUrl);
      }
      return;
    }); 

    /* ---- FUNCTION TO UPDATE CANVAS ---- */
    function updateCanvasWithUrl(url) {
      const img = new Image();
      
      img.onload = function() {
        // set max width & height
        // set width to match window
        if (img.width > window.innerWidth) {
          canvas.width = window.innerWidth;
          img.width = window.innerWidth;
        }
        // set height to match window
        if (img.height > window.innerHeight) {
          canvas.height = window.innerHeight;
          img.height = window.innerHeight;
        }
        // if everything matches set the canvas width & height
        if (img.width <= window.innerWidth && img.height <= window.innerHeight) { 
          canvas.width = img.width;
          canvas.height = img.height;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
      };
      img.src = url;
    }

    /* ---- FUNCTION TO RETURN URL/SRC OF CURRENT IMG ---- */
    function getUrl(file) {
      const url = URL.createObjectURL(file);
      // update global var
      currentFileUrl = url;
      return url;
    }
    </script>
    
    {{ bootstrap.load_js() }}
  </body>
</html>

